import os
import pandas as pd
import csv
import json


syestem_prompt = """
You are a virtual agent. The Virtual Agent is designed to help a human user complete specified tasks 
(such as app usage, web navigation, web content Q&A, etc.) on various platform applications (such as websites, mobile 
devices, operation systems, etc.) based on given instructions.

You will predict the next action based on following content [INSTRUCTION], [OBSERVATION], [REASON_STEPS] and [DIMENSION]:
1. [INSTRUCTION]: It is your ultimate goal, and all your actions are aimed at completing this task.
2. [OBSERVATION]: It is an observation of an image, which is the screenshot of the platform (such as computer screen).
3. [REASON_STEPS]: They are the trajectory of the actions you performed in the past to complete the instruction, from which you can understand how you thought in order to complete the instruction. If it is empty, it means it is currently the first step.
4. [DIMENSION]: It indicates your tendency to perform actions, and your actions may not necessarily satisfy all dimensions. For example, one of your actions can complete a task but may not be efficient. But when predicting the next action, you need to make predictions based on a given dimension, which may be a single dimension or a combination of all dimensions.

<DIMENSION TYPES>
Please evaluate the quality of each step of the Agent operation based on the dimensions provided follow, with scores given in specific dimension. The higher the value, the more satisfied this attribute is.
1. [INFERENCE POTENTIAL]
    1.1 Meaning: It indicates the potential of the step to complete the task, which is the probability of a step reaching the completion of the task.
    1.2 Design motivation: The more correct steps lead to a higher probability of success in the final task, and the more incorrect steps lead to a higher probability of failure in the final task. Different steps have different potential to complete the task. If one step of the agent is to follow the Instructions to complete the task, then this step generally has high potential. We can derive the probability of a step leading to success from the N paths generated by that step, which serves as the potential for that step to complete the task.
2. [EFFICIENCY]
    2.1 Meaning: It indicates whether this step is efficient in completing the task. We calculate this metric as the difference between 'the number of steps required to complete the final task after the current step' and 'the number of steps required to complete the final task after the previous step', divided by 'the total number of steps required to complete the task'. This indicates the degree of efficiency improvement in completing tasks after the current step is executed.
    2.2 Design motivation: A basic assumption is that the fewer steps the Agent operates, the more efficient it is, because the consumption of these paths (time consumption, hardware consumption) can be considered to be the least and the efficiency is the highest. Therefore, if the operation of a step can reduce the number of steps required to complete the task as a whole, then it can be considered that the operation of this step is very efficient. For example, after the previous step, it takes 7 steps to complete the task, but after the current step, it only takes 4 steps to complete the task. The difference of 7-4=3 is the efficiency improvement of the current step in completing the final task. A step that is correct does not necessarily mean it is efficient, but a step that is efficient indicates that it can quickly lead to success, so it is the correct step. Generally speaking, some quick operations (such as using shortcut keys, using history records, etc.) for completing INSTRUCTION can be considered efficient.
3. [TASK CONTRIBUTION]
    3.1 Meaning: It indicates the degree to which this step contributes to the completion of the final task. There are good and bad contributions, the correct steps will give a positive contribution, and the wrong steps will give a negative contribution.
    3.2 Design motivation: Different steps contribute differently to the completion of the final task, with good steps helping to accomplish the task and bad steps hindering it. Good steps should be rewarded positively, while bad steps should be punished negatively. If each step is correct and the total number of steps is 5, then the contribution of each step can be considered as 1/5, meaning that each step completes 1/5 of the final task. If 4 more steps are needed from the current step and the current step is incorrect, then the contribution of the current step is -1/4, indicating that it hinders 1/4 of the final task progress.
4. [Task Relevance]
    4.1 Meaning: It indicates is whether the operation of the Agent is related to achieving the INSTRUCTION. 
    4.2 Design motivation: Some operational steps may prevent the task from being completed, but they are related to the task (for example, we need to ask the agent to take notes, and the agent takes notes, which is related to the task, but the recorded note content is incorrect, indicating that this is an incorrect step). Some operational steps may be meaningless, but they can still lead to task completion (such as clicking on a blank screen without generating any response, which is unrelated to the task, but the agent's subsequent actions can still result in task success). Therefore, an indicator is needed to identify whether the current step of operation is related to the task.
5. [Coherence]. 
    5.1 Meaning: It represents the compactness and coherence between the current step and the previous step. 
    5.2 Design motivation: Some operations, although task related, not inefficient, and highly likely to lead to success, lack coherence with the previous step. For example, the task is to "query the Lakers' game results and record them in the Note". The Agent operations are as follows: a Open the browser; b. Open Note; c. Create new notes; d. Search for Lakers games; e. Query the results of the competition; f. Record the results of the competition in your notes. It can be found that the operations of a and b lack coherence, and it is more in line with human preferences to directly search for competition results after opening the browser instead of simultaneously opening Note.
6. [Total].
    Meaning: Integrated decision-making based on the 5 dimensions mentioned earlier
</DIMENSION TYPES>
"""

user_prompt = """
[DIMENSION TYPE]: <DIMENSION TYPE>
[INSTRUCTION]: <INSTRUCTION>
[OBSERVATION]: which is a single image provided.
[REASON_STEPS]: <REASON_STEPS>
"""


def trans_type(type_now):
    if type_now == 'IP':
        type_now = "Inference Potential"
    elif type_now == 'E':
        type_now = "Efficiency"
    elif type_now == 'TC':
        type_now = "Task Contribution"
    elif type_now == 'TR':
        type_now = "Task Relevance"
    elif type_now == 'C':
        type_now = "Coherence"
    elif type_now == 'total':
        type_now = "Total"

    return type_now


def get_messages(type_now, instruction, reason_steps, observation_url, action):
    user_message = user_prompt
    user_message = user_message.replace("<DIMENSION TYPE>", type_now)
    user_message = user_message.replace("<INSTRUCTION>", instruction)
    user_message = user_message.replace("<REASON_STEPS>", reason_steps)

    messages = [
        {
            "role": "system",
            "content": [
                {
                    "type": "text",
                    "text": syestem_prompt,
                }
            ]
        },
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": user_message,
                },
                {
                    "type": "image",
                    "image": observation_url,
                }
            ]
        },
        {
            "role": "assistant",
            "content": action,
        }
    ]
    return messages


csv_file = "Reward_Model_WebArena.csv"
json_file = "Reward_Model_WebArena_useful.json"
dataset_csv_file = "Reward_Model_WebArena_preference_dataset_train_prompt.csv"

task_id_useful_list =  [3, 22, 23, 24, 28, 29, 30, 41, 42, 43, 44, 69, 79, 94, 95, 115, 118, 128, 129, 130, 132, 134, 135, 149, 150, 156, 158, 160, 161, 164, 166, 167, 169, 177, 183, 188, 190, 198, 199, 202, 203, 205, 208, 209, 211, 212, 225, 227, 230, 231, 247, 258, 260, 261, 262, 264, 273, 274, 275, 276, 278, 302, 303, 305, 306, 308, 310, 311, 312, 313, 314, 315, 317, 318, 322, 326, 340, 348, 351, 354, 355, 358, 359, 360, 361, 368, 376, 384, 387, 388, 392, 395, 397, 447, 465, 468, 472, 474, 477, 478, 479, 491, 511, 512, 514, 515, 516, 517, 518, 533, 535, 539, 580, 581, 650, 651, 652, 691, 692, 693, 723, 726, 731, 753, 754, 772, 775, 784, 785, 787, 790, 793, 794, 795]
task_id_useful_test_list =  [491, 258, 794, 652, 274, 130, 731, 211, 479, 161, 190, 322, 693, 41, 132, 29, 384, 183, 517, 150, 149, 69, 355, 95, 387, 305]
task_id_useful_train_list = list(set(task_id_useful_list) - set(task_id_useful_test_list))


data = pd.read_csv(csv_file, encoding="iso-8859-1")
dict = {}
with open(json_file, 'r') as f:
    dict = json.load(f)

IP_list = []
E_list = []
TC_list = []
TR_list = []
C_list = []
all_list = []

with open(dataset_csv_file, 'w', newline='') as file:
    fields = ['compare_id', 'step_idx', 'instruction', 'type', 'reason_steps', 'image_url', 'chosen_action', 'rejected_action', 'chosen', 'rejected', 'chosen_score', 'rejected_score']
    writer = csv.DictWriter(file, fieldnames=fields)
    writer.writeheader()

    for id in task_id_useful_train_list:
        list_now = list(dict[str(id)].keys())
        # print("length = ", len(list_now))

        traj_dict = {}
        traj_score_dict = {}

        for i in range(len(list_now)):
            for j in range(i + 1, len(list_now)):
                now = "WebArena_" + str(list_now[i]) + "_vs_" + str(list_now[j])
                now_reverse = "WebArena_" + str(list_now[j]) + "_vs_" + str(list_now[i])
                # print(list_now[i], list_now[j])
                min_len = min(len(dict[str(id)][list_now[i]]), len(dict[str(id)][list_now[j]]))
                # print("min_len = ", min_len)

                reason_steps = ''
                step_idx = 0

                for k in range(min_len):
                    step_idx += 1
                    try:
                        if dict[str(id)][list_now[i]][str(k + 1)]["action"] == dict[str(id)][list_now[j]][str(k + 1)]["action"]:
                            reason_steps += "Step " + str(step_idx) + " : " + dict[str(id)][list_now[i]][str(k + 1)]["action"] + "\n\n"
                            continue
                        else:
                            instruction = dict[str(id)][list_now[i]][str(k + 1)]["instruction"]
                            observation_url = dict[str(id)][list_now[i]][str(k + 1)]["observation_url"]

                            answer1_IP = dict[str(id)][list_now[i]][str(k + 1)]["IP"]
                            answer1_E = dict[str(id)][list_now[i]][str(k + 1)]["E"]
                            answer1_TC = dict[str(id)][list_now[i]][str(k + 1)]["TC"]
                            answer1_TR = dict[str(id)][list_now[i]][str(k + 1)]["TR"]
                            answer1_C = dict[str(id)][list_now[i]][str(k + 1)]["C"]
                            answer1_total = answer1_IP * 5 + answer1_E * 5 + answer1_TC * 3 + answer1_TR + answer1_C
                            action1 = dict[str(id)][list_now[i]][str(k + 1)]["action"]

                            answer2_IP = dict[str(id)][list_now[j]][str(k + 1)]["IP"]
                            answer2_E = dict[str(id)][list_now[j]][str(k + 1)]["E"]
                            answer2_TC = dict[str(id)][list_now[j]][str(k + 1)]["TC"]
                            answer2_TR = dict[str(id)][list_now[j]][str(k + 1)]["TR"]
                            answer2_C = dict[str(id)][list_now[j]][str(k + 1)]["C"]
                            answer2_total = answer2_IP * 5 + answer2_E * 5 + answer2_TC * 3 + answer2_TR + answer2_C
                            action2 = dict[str(id)][list_now[j]][str(k + 1)]["action"]


                            if answer1_IP > answer2_IP:
                                IP_list.append(now)
                                chosen = get_messages(trans_type('IP'), instruction, reason_steps, observation_url, action1)
                                rejected = get_messages(trans_type('IP'), instruction, reason_steps, observation_url, action2)
                                chosen_score = answer1_IP
                                rejected_score = answer2_IP
                                writer.writerow(
                                    {'compare_id': now, 'step_idx': step_idx,
                                     'instruction': instruction, 'type': 'IP',
                                     'reason_steps': reason_steps, 'image_url': observation_url,
                                     'chosen_action': action1, 'rejected_action': action2,
                                     'chosen': chosen, 'rejected': rejected,
                                     'chosen_score': chosen_score, 'rejected_score': rejected_score})
                            elif answer1_IP < answer2_IP:
                                IP_list.append(now_reverse)
                                chosen = get_messages(trans_type('IP'), instruction, reason_steps, observation_url, action2)
                                rejected = get_messages(trans_type('IP'), instruction, reason_steps, observation_url, action1)
                                chosen_score = answer2_IP
                                rejected_score = answer1_IP
                                writer.writerow(
                                    {'compare_id': now, 'step_idx': step_idx,
                                     'instruction': instruction, 'type': 'IP',
                                     'reason_steps': reason_steps, 'image_url': observation_url,
                                     'chosen_action': action2, 'rejected_action': action1,
                                     'chosen': chosen, 'rejected': rejected,
                                     'chosen_score': chosen_score, 'rejected_score': rejected_score})

                            if answer1_E > answer2_E:
                                E_list.append(now)
                                chosen = get_messages(trans_type('E'), instruction, reason_steps, observation_url, action1)
                                rejected = get_messages(trans_type('E'), instruction, reason_steps, observation_url, action2)
                                chosen_score = answer1_E
                                rejected_score = answer2_E
                                writer.writerow(
                                    {'compare_id': now, 'step_idx': step_idx,
                                     'instruction': instruction, 'type': 'E',
                                     'reason_steps': reason_steps, 'image_url': observation_url,
                                     'chosen_action': action1, 'rejected_action': action2,
                                     'chosen': chosen, 'rejected': rejected,
                                     'chosen_score': chosen_score, 'rejected_score': rejected_score})
                            elif answer1_E < answer2_E:
                                E_list.append(now_reverse)
                                chosen = get_messages(trans_type('E'), instruction, reason_steps, observation_url, action2)
                                rejected = get_messages(trans_type('E'), instruction, reason_steps, observation_url, action1)
                                chosen_score = answer2_E
                                rejected_score = answer1_E
                                writer.writerow(
                                    {'compare_id': now, 'step_idx': step_idx,
                                     'instruction': instruction, 'type': 'E',
                                     'reason_steps': reason_steps, 'image_url': observation_url,
                                     'chosen_action': action2, 'rejected_action': action1,
                                     'chosen': chosen, 'rejected': rejected,
                                     'chosen_score': chosen_score, 'rejected_score': rejected_score})

                            if answer1_TC > answer2_TC:
                                TC_list.append(now)
                                chosen = get_messages(trans_type('TC'), instruction, reason_steps, observation_url, action1)
                                rejected = get_messages(trans_type('TC'), instruction, reason_steps, observation_url, action2)
                                chosen_score = answer1_TC
                                rejected_score = answer2_TC
                                writer.writerow(
                                    {'compare_id': now, 'step_idx': step_idx,
                                     'instruction': instruction, 'type': 'TC',
                                     'reason_steps': reason_steps, 'image_url': observation_url,
                                     'chosen_action': action1, 'rejected_action': action2,
                                     'chosen': chosen, 'rejected': rejected,
                                     'chosen_score': chosen_score, 'rejected_score': rejected_score})
                            elif answer1_TC < answer2_TC:
                                TC_list.append(now_reverse)
                                chosen = get_messages(trans_type('TC'), instruction, reason_steps, observation_url, action2)
                                rejected = get_messages(trans_type('TC'), instruction, reason_steps, observation_url, action1)
                                chosen_score = answer2_TC
                                rejected_score = answer1_TC
                                writer.writerow(
                                    {'compare_id': now, 'step_idx': step_idx,
                                     'instruction': instruction, 'type': 'TC',
                                     'reason_steps': reason_steps, 'image_url': observation_url,
                                     'chosen_action': action2, 'rejected_action': action1,
                                     'chosen': chosen, 'rejected': rejected,
                                     'chosen_score': chosen_score, 'rejected_score': rejected_score})

                            if answer1_TR > answer2_TR:
                                TR_list.append(now)
                                chosen = get_messages(trans_type('TR'), instruction, reason_steps, observation_url, action1)
                                rejected = get_messages(trans_type('TR'), instruction, reason_steps, observation_url, action2)
                                chosen_score = answer1_TR
                                rejected_score = answer2_TR
                                writer.writerow(
                                    {'compare_id': now, 'step_idx': step_idx,
                                     'instruction': instruction, 'type': 'TR',
                                     'reason_steps': reason_steps, 'image_url': observation_url,
                                     'chosen_action': action1, 'rejected_action': action2,
                                     'chosen': chosen, 'rejected': rejected,
                                     'chosen_score': chosen_score, 'rejected_score': rejected_score})
                            elif answer1_TR > answer2_TR:
                                TR_list.append(now_reverse)
                                chosen = get_messages(trans_type('TR'), instruction, reason_steps, observation_url, action2)
                                rejected = get_messages(trans_type('TR'), instruction, reason_steps, observation_url, action1)
                                chosen_score = answer2_TR
                                rejected_score = answer1_TR
                                writer.writerow(
                                    {'compare_id': now, 'step_idx': step_idx,
                                     'instruction': instruction, 'type': 'TR',
                                     'reason_steps': reason_steps, 'image_url': observation_url,
                                     'chosen_action': action2, 'rejected_action': action1,
                                     'chosen': chosen, 'rejected': rejected,
                                     'chosen_score': chosen_score, 'rejected_score': rejected_score})

                            if answer1_C > answer2_C:
                                C_list.append(now)
                                chosen = get_messages(trans_type('C'), instruction, reason_steps, observation_url, action1)
                                rejected = get_messages(trans_type('C'), instruction, reason_steps, observation_url, action2)
                                chosen_score = answer1_C
                                rejected_score = answer2_C
                                writer.writerow(
                                    {'compare_id': now, 'step_idx': step_idx,
                                     'instruction': instruction, 'type': 'C',
                                     'reason_steps': reason_steps, 'image_url': observation_url,
                                     'chosen_action': action1, 'rejected_action': action2,
                                     'chosen': chosen, 'rejected': rejected,
                                     'chosen_score': chosen_score, 'rejected_score': rejected_score})
                            elif answer1_C > answer2_C:
                                C_list.append(now_reverse)
                                chosen = get_messages(trans_type('C'), instruction, reason_steps, observation_url, action2)
                                rejected = get_messages(trans_type('C'), instruction, reason_steps, observation_url, action1)
                                chosen_score = answer2_C
                                rejected_score = answer1_C
                                writer.writerow(
                                    {'compare_id': now, 'step_idx': step_idx,
                                     'instruction': instruction, 'type': 'C',
                                     'reason_steps': reason_steps, 'image_url': observation_url,
                                     'chosen_action': action2, 'rejected_action': action1,
                                     'chosen': chosen, 'rejected': rejected,
                                     'chosen_score': chosen_score, 'rejected_score': rejected_score})


                            if answer1_total > answer2_total:
                                all_list.append(now)
                                chosen = get_messages(trans_type('total'), instruction, reason_steps, observation_url, action1)
                                rejected = get_messages(trans_type('total'), instruction, reason_steps, observation_url, action2)
                                chosen_score = answer1_total
                                rejected_score = answer2_total
                                writer.writerow(
                                    {'compare_id': now, 'step_idx': step_idx,
                                     'instruction': instruction, 'type': 'total',
                                     'reason_steps': reason_steps, 'image_url': observation_url,
                                     'chosen_action': action1, 'rejected_action': action2,
                                     'chosen': chosen, 'rejected': rejected,
                                     'chosen_score': chosen_score, 'rejected_score': rejected_score})
                            elif answer1_total > answer2_total:
                                all_list.append(now_reverse)
                                chosen = get_messages(trans_type('total'), instruction, reason_steps, observation_url, action2)
                                rejected = get_messages(trans_type('total'), instruction, reason_steps, observation_url, action1)
                                chosen_score = answer2_total
                                rejected_score = answer1_total
                                writer.writerow(
                                    {'compare_id': now, 'step_idx': step_idx,
                                     'instruction': instruction, 'type': 'total',
                                     'reason_steps': reason_steps, 'image_url': observation_url,
                                     'chosen_action': action2, 'rejected_action': action1,
                                     'chosen': chosen, 'rejected': rejected,
                                     'chosen_score': chosen_score, 'rejected_score': rejected_score})

                            break

                    except Exception as e:
                        break

print("len(IP_list) = ", len(IP_list)) # 514
# print("IP_list = ", IP_list)
print("\n")
print("len(E_list) = ", len(E_list)) # 1232
# print("E_list = ", E_list)
print("\n")
print("len(TC_list) = ", len(TC_list)) # 1225
# print("TC_list = ", TC_list)
print("\n")
print("len(TR_list) = ", len(TR_list)) # 237
# print("TR_list = ", TR_list)
print("\n")
print("len(C_list) = ", len(C_list)) # 174
# print("E_list = ", E_list)
print("\n")
print("len(all_list) = ", len(all_list)) # 609
# print("all_list = ", all_list)