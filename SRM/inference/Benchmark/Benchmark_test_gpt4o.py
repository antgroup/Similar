# 为每张图像的观感打分
import pandas as pd
import requests
import os
from tqdm import tqdm
import json
import time
import concurrent.futures
from functools import partial


system_prompt = '''
  You are an expert in evaluating the performance of a Virtual Agent. The Virtual Agent is designed to help a human user complete specified tasks (such as app usage, web navigation, web content Q&A, etc.) on various platform applications (such as websites, mobile devices, operation systems, etc.) based on given instructions. 
  Given the user’s *INSTRUCTION*, the *OBSERVATION* of current platforms, the action *TRAJECTORY* of the agent, the two *ACTION_1* and *ACTION_2* predicted by the agent, and the current action step number *STEP_IDX*. Your GOAL is to help me complete *step-wise evaluation*, that is, *evaluate the quality of the Agent's ACTION* in a specific dimension. 
  Please evaluate the quality of the Agent ACTION based one of the given <EVALUATION DIMENSION> and determine which one is better: *ACTION_1* or *ACTION_2*. 
  If *ACTION_1* is better, please output "1" and the Reason; If *ACTION_2* is better, please output "2" and the Reason. 
  Note that please do not output answers such as 'two actions are similar'. Please make a choice and output the number and corresponding reason.
\n

<Word Meaning>
1. *INSTRUCTION*: refers to the command of human users to the Agent, which is the specific content that the Agent needs to complete the task on a specific platform, that is, the ultimate GOAL of the Agent.
2. *OBSERVATION*: refers to the specific information of the current platform state that an agent can observe on the platform where the task needs to be completed, which is the environment in which the agent is currently located. In our task, observations are presented in the form of images, known as screenshots.
3. *TRAJECTORY*: refers to the action prediction made by an agent in the past to complete the INSTRUCTION, which records all actions taken by the agent from the first step to the current step. If this is the first step, then the trajectory is empty.
4. *ACTION*: refers to the predicted operation of the Agent in the current state to complete the INSTARCTION in the current step. This operation generally refers to a simple action command, such as "CLICK", "TYPE", etc. Note that ACTION is the result predicted by the agent after observing the current OBSERVATION, and the Agent often cannot complete the task in one step.
5. *STEP_IDX*: refers to the sequence number of the Agent executing the current ACTION to complete the INSTRUCTION.
</Word Meaning>
\n

<EVALUATION DIMENSION>
Please evaluate the quality of each step of the Agent operation based on the dimensions provided follow, with scores given in specific dimension. The higher the value, the more satisfied this attribute is.
1. [INFERENCE POTENTIAL]
    1.1 Meaning: It indicates the potential of the step to complete the task, which is the probability of a step reaching the completion of the task.
    1.2 Design motivation: The more correct steps lead to a higher probability of success in the final task, and the more incorrect steps lead to a higher probability of failure in the final task. Different steps have different potential to complete the task. If one step of the agent is to follow the Instructions to complete the task, then this step generally has high potential. We can derive the probability of a step leading to success from the N paths generated by that step, which serves as the potential for that step to complete the task.
    1.3 Range of metric scores after mapping: *{0, 1, 2, 3}*. The larger the value, the greater the potential for the step.
2. [EFFICIENCY]
    2.1 Meaning: It indicates whether this step is efficient in completing the task. We calculate this metric as the difference between 'the number of steps required to complete the final task after the current step' and 'the number of steps required to complete the final task after the previous step', divided by 'the total number of steps required to complete the task'. This indicates the degree of efficiency improvement in completing tasks after the current step is executed.
    2.2 Design motivation: A basic assumption is that the fewer steps the Agent operates, the more efficient it is, because the consumption of these paths (time consumption, hardware consumption) can be considered to be the least and the efficiency is the highest. Therefore, if the operation of a step can reduce the number of steps required to complete the task as a whole, then it can be considered that the operation of this step is very efficient. For example, after the previous step, it takes 7 steps to complete the task, but after the current step, it only takes 4 steps to complete the task. The difference of 7-4=3 is the efficiency improvement of the current step in completing the final task. A step that is correct does not necessarily mean it is efficient, but a step that is efficient indicates that it can quickly lead to success, so it is the correct step. Generally speaking, some quick operations (such as using shortcut keys, using history records, etc.) for completing INSTRUCTION can be considered efficient.
    2.3 Range of metric scores after mapping: *{1, 2, 3, 4, 5}*. The larger the value, the more efficient the step.
3. [TASK CONTRIBUTION]
    3.1 Meaning: It indicates the degree to which this step contributes to the completion of the final task. There are good and bad contributions, the correct steps will give a positive contribution, and the wrong steps will give a negative contribution.
    3.2 Design motivation: Different steps contribute differently to the completion of the final task, with good steps helping to accomplish the task and bad steps hindering it. Good steps should be rewarded positively, while bad steps should be punished negatively. If each step is correct and the total number of steps is 5, then the contribution of each step can be considered as 1/5, meaning that each step completes 1/5 of the final task. If 4 more steps are needed from the current step and the current step is incorrect, then the contribution of the current step is -1/4, indicating that it hinders 1/4 of the final task progress.
    3.3 Range of values after mapping: *{-3, -2, -1, 0, 1, 2, 3}*. The larger the value, the greater the contribution of the step to the task. Positive values indicate that the step has a positive contribution, which promotes the completion of the task, while negative values indicate that the step has a negative contribution, which hinders the completion of the task.
4. [Task Relevance]
    4.1 Meaning: It indicates is whether the operation of the Agent is related to achieving the INSTRUCTION. 
    4.2 Design motivation: Some operational steps may prevent the task from being completed, but they are related to the task (for example, we need to ask the agent to take notes, and the agent takes notes, which is related to the task, but the recorded note content is incorrect, indicating that this is an incorrect step). Some operational steps may be meaningless, but they can still lead to task completion (such as clicking on a blank screen without generating any response, which is unrelated to the task, but the agent's subsequent actions can still result in task success). Therefore, an indicator is needed to identify whether the current step of operation is related to the task.
    4.3 Range of values after mapping: *{0, 1}*. The larger the value, the greater the correlation between the step and the task, that is, 1 indicates that the operation has a high task correlation, while 0 indicates that the operation has almost no correlation with the task.
5. [Coherence]. 
    5.1 Meaning: It represents the compactness and coherence between the current step and the previous step. 
    5.2 Design motivation: Some operations, although task related, not inefficient, and highly likely to lead to success, lack coherence with the previous step. For example, the task is to "query the Lakers' game results and record them in the Note". The Agent operations are as follows: a Open the browser; b. Open Note; c. Create new notes; d. Search for Lakers games; e. Query the results of the competition; f. Record the results of the competition in your notes. It can be found that the operations of a and b lack coherence, and it is more in line with human preferences to directly search for competition results after opening the browser instead of simultaneously opening Note.
    5.3 Range of values after mapping: *{0, 1}*. The larger the value, the greater the coherence of the step, that is, 1 indicates that the operation has greater coherence, which is in line with human preferences, while 0 indicates lower coherence of the operation.
6. [Total].
    Meaning: Integrated decision-making based on the 5 dimensions mentioned earlier
</EVALUATION DIMENSION>
\n

Please only return JSON format content to ensure it can be parsed by json.loads()
<Output Format>
{"choose":<1 or 2>, "reason": <Reason for judgment>}
</Output Format>
\n
'''

user_prompt = """
[EVALUATION DIMENSION]: <EVALUATION DIMENSION>
[INSTRUCTION]: <INSTRUCTION>
[OBSERVATION]: which is a single image provided.
[TRAJECTORY]: <TRAJECTORY>
[ACTION_1]: <ACTION_1>
[ACTION_2]: <ACTION_2>
[STEP_IDX]: <STEP_IDX>
"""

MAX_RETRIES = 10
N = 10


def ask_chatgpt_ant(messages):
    param = get_default_config(model="gpt-4o")
    param["queryConditions"]["model"] = "gpt-4o"
    param["queryConditions"]["temperature"] = "0.2"

    param["queryConditions"]["messages"] = messages
    try:
        response = ask_chatgpt(param)
        # print(response)
        return response
    except Exception as e:
        # print(e)
        # raise Exception(e)
        return False


def trans_type(type_now):
    if type_now == 'IP':
        type_now = "Inference Potential"
    elif type_now == 'E':
        type_now = "Efficiency"
    elif type_now == 'TC':
        type_now = "Task Contribution"
    elif type_now == 'TR':
        type_now = "Task Relevance"
    elif type_now == 'C':
        type_now = "Coherence"
    elif type_now == 'total':
        type_now = "Total"

    return type_now

def process_single_image(row, results_list):
    compare_id = row['compare_id']
    type_now = row['type']
    type_now = trans_type(type_now)
    instruction = row["instruction"]
    observation = row["image_url"]
    trajectory = row["reason_steps"]
    if pd.isna(trajectory):
        trajectory = "Let's complete the task step by step."
    action1 = row["chosen_action"]
    action2 = row["rejected_action"]
    step_idx = row["step_idx"]

    user_message = user_prompt
    user_message = user_message.replace("<EVALUATION DIMENSION>", type_now)
    user_message = user_message.replace("<INSTRUCTION>", instruction)
    user_message = user_message.replace("<TRAJECTORY>", trajectory)
    user_message = user_message.replace("<ACTION_1>", action1)
    user_message = user_message.replace("<ACTION_2>", action2)
    user_message = user_message.replace("<STEP_IDX>", str(step_idx))

    messages = [
        {
            "role": "system",
            "content": [
                {
                    "type": "text",
                    "text": system_prompt,
                }
            ]
        },
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": user_message,
                },
                {
                    "type": "image_url",
                    "image_url": {"url": observation},
                },
                # {
                #     "type": "image",
                #     "image": observation,
                # }
            ]
        }
    ]

    # retry_cnt = 0
    # while retry_cnt < MAX_RETRIES:
    #     retry_cnt += 1
    #     try:
    #         time.sleep(2)
    #         response = ask_chatgpt_ant(messages)
    #         if response[0] == '`':
    #             response = response[8:-4]
    #         response = json.loads(response)
    #         print(response)
    #         choose = response['choose']
    #         reason = response["reason"]
    #         results_list.append({"compare_id": compare_id, "choose": choose, "reason": reason})
    #         return
    #     except Exception as e:
    #         print(e)
    #         if 'mosn limit' in str(e):
    #             retry_cnt -= 1
    # results_list.append({"compare_id": compare_id, "choose": None, "reason": None})

    while True:
        time.sleep(2)
        response = ask_chatgpt_ant(messages)
        if ('choose' in response):
            if response[0] == '`':
                response = response[8:-4]
            response = json.loads(response)
            print(response)
            choose = response['choose']
            reason = response["reason"]
            results_list.append({"compare_id": compare_id, "choose": choose, "reason": reason})
            return


# df = pd.read_csv("/mnt/prev_nas/virtual_agent/MBC/Reward_Model_csv_zeta/Reward_Model_preference_dataset_test_modify.csv")
# df = pd.read_csv("~/Downloads/Reward_Model_csv_zeta/Reward_Model_preference_dataset_test_modify.csv")


def count_rest():
    df = pd.read_csv("~/Downloads/RLHF-Reward-Modeling/similar/Benchmark_test_gpt4o_3.csv")
    rest = []
    for index, row in df.iterrows():
        if not (row["choose"] == 1.0 or row["choose"] == 2.0):
            rest.append(row["compare_id"])
    # print("rest = ", rest)
    return len(rest)

while(count_rest() != 0):
    df = pd.read_csv("~/Downloads/RLHF-Reward-Modeling/similar/Benchmark_test_gpt4o_3.csv")
    rest = []
    for index, row in df.iterrows():
        if not (row["choose"] == 1.0 or row["choose"] == 2.0):
            rest.append(row["compare_id"])
    # print("rest = ", rest)

    df_rest = df.loc[df['compare_id'].isin(rest)]
    print("len(df) = ", df_rest.shape[0])

    # 存储所有结果的列表
    results_list = []

    # 使用线程池进行并行处理
    with concurrent.futures.ThreadPoolExecutor(max_workers=32) as executor:
        futures = []
        for _, row in df_rest.iterrows():
            future = executor.submit(process_single_image, row, results_list)
            futures.append(future)

        # 使用tqdm显示进度
        for future in tqdm(concurrent.futures.as_completed(futures), total=len(futures)):
            if len(results_list) % 10 == 0:
                temp_results = results_list.copy()
                for i in temp_results:
                    df.loc[df['compare_id'] == i['compare_id'], 'choose'] = i['choose']
                    df.loc[df['compare_id'] == i['compare_id'], 'reason'] = i['reason']
                df.to_csv('Benchmark_test_gpt4o_3.csv', index=False, encoding='utf-8')

    for i in results_list:
        df.loc[df['compare_id'] == i['compare_id'], 'choose'] = i['choose']
        df.loc[df['compare_id'] == i['compare_id'], 'reason'] = i['reason']
    df.to_csv('Benchmark_test_gpt4o_3.csv', index=False, encoding='utf-8')
