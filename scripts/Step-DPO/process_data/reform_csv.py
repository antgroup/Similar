import os
import pandas as pd
import csv
import json

import requests
from PIL import Image
from io import BytesIO

# from process_data.train_prompt import system_prompt
system_prompt = '''
  You are an expert in evaluating the performance of a Virtual Agent. The Virtual Agent is designed to help a human user complete specified tasks (such as app usage, web navigation, web content Q&A, etc.) on various platform applications (such as websites, mobile devices, operation systems, etc.) based on given instructions. 
  Given the user's *INSTRUCTION*, the *OBSERVATION* of current platforms and the current action step number *STEP_IDX*, your GOAL is to help me complete *step-wise multi-dimensional evaluation*, that is, *evaluate the quality of the Agent's ACTION*. Please predict the Agent's current *ACTION* and evaluate the quality of the Agent ACTION based on the given <Evaluation Dimensions>. 
  ATTENTION!! If the current *ACTION* has been provided, your goal is just to evaluate the quality of the Agent ACTION based on the given <Evaluation Dimensions> without predicting the current ACTION.
\n

<Word Meaning>
1. *INSTRUCTION*: refers to the command of human users to the Agent, which is the specific content that the Agent needs to complete the task on a specific platform, that is, the ultimate GOAL of the Agent.
2. *OBSERVATION*: refers to the specific information of the current platform state that an agent can observe on the platform where the task needs to be completed, which is the environment in which the agent is currently located. In our task, observations are presented in the form of images, known as screenshots.
3. *ACTION*: refers to the predicted operation of the Agent in the current state to complete the INSTARCTION in the current step. This operation generally refers to a simple action command, such as "CLICK", "TYPE", etc. Note that ACTION is the result predicted by the agent after observing the current OBSERVATION, and the Agent often cannot complete the task in one step.
4. *STEP_IDX*: refers to the sequence number of the Agent executing the current ACTION to complete the INSTRUCTION.
</Word Meaning>
\n

<Evaluation Dimensions>
Please evaluate the quality of each step of the Agent operation based on the dimensions provided follow, with scores given in specific dimension. The higher the value, the more satisfied this attribute is.
1. [INFERENCE POTENTIAL]
    1.1 Meaning: It indicates the potential of the step to complete the task, which is the probability of a step reaching the completion of the task.
    1.2 Design motivation: The more correct steps lead to a higher probability of success in the final task, and the more incorrect steps lead to a higher probability of failure in the final task. Different steps have different potential to complete the task. If one step of the agent is to follow the Instructions to complete the task, then this step generally has high potential. We can derive the probability of a step leading to success from the N paths generated by that step, which serves as the potential for that step to complete the task.
    1.3 Range of metric scores after mapping: *{0, 1, 2, 3}*. The larger the value, the greater the potential for the step.
2. [EFFICIENCY]
    2.1 Meaning: It indicates whether this step is efficient in completing the task. We calculate this metric as the difference between 'the number of steps required to complete the final task after the current step' and 'the number of steps required to complete the final task after the previous step', divided by 'the total number of steps required to complete the task'. This indicates the degree of efficiency improvement in completing tasks after the current step is executed.
    2.2 Design motivation: A basic assumption is that the fewer steps the Agent operates, the more efficient it is, because the consumption of these paths (time consumption, hardware consumption) can be considered to be the least and the efficiency is the highest. Therefore, if the operation of a step can reduce the number of steps required to complete the task as a whole, then it can be considered that the operation of this step is very efficient. For example, after the previous step, it takes 7 steps to complete the task, but after the current step, it only takes 4 steps to complete the task. The difference of 7-4=3 is the efficiency improvement of the current step in completing the final task. A step that is correct does not necessarily mean it is efficient, but a step that is efficient indicates that it can quickly lead to success, so it is the correct step. Generally speaking, some quick operations (such as using shortcut keys, using history records, etc.) for completing INSTRUCTION can be considered efficient.
    2.3 Range of metric scores after mapping: *{1, 2, 3, 4, 5}*. The larger the value, the more efficient the step.
3. [TASK CONTRIBUTION]
    3.1 Meaning: It indicates the degree to which this step contributes to the completion of the final task. There are good and bad contributions, the correct steps will give a positive contribution, and the wrong steps will give a negative contribution.
    3.2 Design motivation: Different steps contribute differently to the completion of the final task, with good steps helping to accomplish the task and bad steps hindering it. Good steps should be rewarded positively, while bad steps should be punished negatively. If each step is correct and the total number of steps is 5, then the contribution of each step can be considered as 1/5, meaning that each step completes 1/5 of the final task. If 4 more steps are needed from the current step and the current step is incorrect, then the contribution of the current step is -1/4, indicating that it hinders 1/4 of the final task progress.
    3.3 Range of values after mapping: *{-3, -2, -1, 0, 1, 2, 3}*. The larger the value, the greater the contribution of the step to the task. Positive values indicate that the step has a positive contribution, which promotes the completion of the task, while negative values indicate that the step has a negative contribution, which hinders the completion of the task.
4. [Task Relevance]
    4.1 Meaning: It indicates is whether the operation of the Agent is related to achieving the INSTRUCTION. 
    4.2 Design motivation: Some operational steps may prevent the task from being completed, but they are related to the task (for example, we need to ask the agent to take notes, and the agent takes notes, which is related to the task, but the recorded note content is incorrect, indicating that this is an incorrect step). Some operational steps may be meaningless, but they can still lead to task completion (such as clicking on a blank screen without generating any response, which is unrelated to the task, but the agent's subsequent actions can still result in task success). Therefore, an indicator is needed to identify whether the current step of operation is related to the task.
    4.3 Range of values after mapping: *{0, 1}*. The larger the value, the greater the correlation between the step and the task, that is, 1 indicates that the operation has a high task correlation, while 0 indicates that the operation has almost no correlation with the task.
5. [Coherence]. 
    5.1 Meaning: It represents the compactness and coherence between the current step and the previous step. 
    5.2 Design motivation: Some operations, although task related, not inefficient, and highly likely to lead to success, lack coherence with the previous step. For example, the task is to "query the Lakers' game results and record them in the Note". The Agent operations are as follows: a Open the browser; b. Open Note; c. Create new notes; d. Search for Lakers games; e. Query the results of the competition; f. Record the results of the competition in your notes. It can be found that the operations of a and b lack coherence, and it is more in line with human preferences to directly search for competition results after opening the browser instead of simultaneously opening Note.
    5.3 Range of values after mapping: *{0, 1}*. The larger the value, the greater the coherence of the step, that is, 1 indicates that the operation has greater coherence, which is in line with human preferences, while 0 indicates lower coherence of the operation.
</Evaluation Dimensions>
\n

<Requirements>
1. Please rate the current steps of the Agent based on the 5 dimensions provided above, and explain the reasons for the rating.
2. Please note that the values of each dimension must be within the given range of values.
3. We represent the [Total Score] of the Agent's current step operation as the sum of 5 dimension values.
4. You should have the ability to distinguish the quality of any two steps in the two operation sequences executed by the Agent based on the same INSTRUCTION. For example, for the same INSTRUCTION, the Agent has two operation sequences A and B. A_3 represents STEP_IDX=3 in operation sequence A, which is the third step operation, and B_3 represents STEP_IDX=3 in operation sequence B, which is the third step operation. If the [Total Score] of the 5 dimensions of A_3 is greater than the total score of the 5 dimensions of B_3, then it can be considered that the quality of step A_3 is better than that of B_3.
</Requirements>
\n

<Output Format>
INSTRUCTION*: INSTRUCTION* \n
STEP *STEP_IDX* : *ACTION* \n
Evaluation: \n
    + [INFERENCE POTENTIAL]: Dimension Score. \n
    + [EFFICIENCY]: Dimension Score. \n
    + [TASK CONTRIBUTION]: Dimension Score. \n
    + [Task Relevance]: Dimension Scoren. \n
    + [Coherence]: Dimension Score. \n
Total Score: [Total Score]\n
</Output Format>
\n

<Example>
INSTRUCTION: "Could you help me convert the image located at '/home/user/logo.png' to '.svg' format?" \n
STEP 10:  Click on "Show Applications" \n
Evaluation: \n
    + [INFERENCE POTENTIAL]: 3. \n
    + [EFFICIENCY]: 4. \n
    + [TASK CONTRIBUTION]: 2. \n
    + [Task Relevance]: 1. \n
    + [Coherence]: 1. \n
Total Score: 11 \n
</Example>
'''

answer_template = '''
INSTRUCTION: <INSTRUCTION> \n
STEP <STEP_IDX> : <ACTION> \n
Evaluation: \n
    + [INFERENCE POTENTIAL]: <IP>. \n
    + [EFFICIENCY]: <E>. \n
    + [TASK CONTRIBUTION]: <TC>. \n
    + [Task Relevance]: <TR>. \n
    + [Coherence]: <C>. \n
Total Score: <TS> \n
'''

def map_IP (IP):
    if IP == 3:
        return 5
    elif IP == 0:
        return 1
    elif IP == 1:
        return 2
    elif IP == 2:
        return 4

csv_file = "generate_data/Reward_Model3.csv"
json_file = "generate_data/Reward_Model3.json"
reform_csv_file = "generate_data/Reward_Model3_reform_11.3.csv"

data = pd.read_csv(csv_file, encoding='iso-8859-1')

completed_id =  [115, 118, 126, 128, 132, 134, 135, 149, 150, 156, 158, 160, 161, 164, 166, 167, 169, 177, 183, 188, 190, 198, 199, 202, 203, 205, 208, 209, 211, 212, 22, 225, 227, 23, 230, 231, 233, 239, 24, 247, 25, 258, 260, 261, 262, 264, 269, 271, 273, 274, 275, 276, 278, 28, 29, 298, 3, 30, 302, 303, 305, 306, 308, 310, 311, 312, 313, 314, 315, 317, 318, 322, 326, 340, 344, 348, 350, 351, 354, 355, 358, 359, 360, 361, 362, 368, 376, 384, 387, 388, 392, 395, 397, 41, 42, 43, 44, 447]

dict = {}
for (index, row) in data.iterrows():
    idx = int(row['task_ID'][:row['task_ID'].find('_')])
    if str(idx) not in dict:
        dict[str(idx)] = {}
    if str(row['task_ID']) not in dict[str(idx)]:
        dict[str(idx)][str(row['task_ID'])] = {}
    dict[str(idx)][str(row['task_ID'])][str(row['step_idx'])] = {}
    dict[str(idx)][str(row['task_ID'])][str(row['step_idx'])]['instruction'] = row['instruction']
    dict[str(idx)][str(row['task_ID'])][str(row['step_idx'])]['observation_url'] = row['observation_url']
    dict[str(idx)][str(row['task_ID'])][str(row['step_idx'])]['action'] = row['action']
    dict[str(idx)][str(row['task_ID'])][str(row['step_idx'])]['IP'] = row['IP']
    dict[str(idx)][str(row['task_ID'])][str(row['step_idx'])]['E'] = row['E']
    dict[str(idx)][str(row['task_ID'])][str(row['step_idx'])]['TC'] = row['TC']
    dict[str(idx)][str(row['task_ID'])][str(row['step_idx'])]['TR'] = row['TR']
    dict[str(idx)][str(row['task_ID'])][str(row['step_idx'])]['C'] = row['C']

if not os.path.exists(json_file):
    with open(json_file, "w") as file:
        json.dump(dict, file)

with open(reform_csv_file, 'w', newline='') as file:
    fields = ['compare', 'step_idx', 'prompt', 'initial_reason_steps', 'image_url', 'chosen', 'rejected']
    writer = csv.DictWriter(file, fieldnames=fields)
    writer.writeheader()

    for id in completed_id:
        list_now = list(dict[str(id)].keys())
        print("sum = ", len(list_now))
        for i in range(len(list_now)):
            for j in range(i + 1, len(list_now)):
                print(list_now[i], list_now[j])
                min_len = min(len(dict[str(id)][list_now[i]]), len(dict[str(id)][list_now[j]]))
                print("min_len = ", min_len)
                initial_reason_steps = 'Let\'s complete the task step by step. \nStep 1: '
                step_idx = 1
                for k in range(min_len):
                    try:
                        prompt = system_prompt + "\n" + "The current INSTRUCTION is :" + dict[str(id)][list_now[i]][str(k + 1)]["instruction"]
                        answer1_IP = dict[str(id)][list_now[i]][str(k + 1)]["IP"]
                        answer1_E = dict[str(id)][list_now[i]][str(k + 1)]["E"]
                        answer1_TC = dict[str(id)][list_now[i]][str(k + 1)]["TC"]
                        answer1_TR = dict[str(id)][list_now[i]][str(k + 1)]["TR"]
                        answer1_C = dict[str(id)][list_now[i]][str(k + 1)]["C"]
                        answer1_total = map_IP(answer1_IP) + answer1_E + answer1_TC + (answer1_TR + answer1_C) * 3

                        answer2_IP = dict[str(id)][list_now[j]][str(k + 1)]["IP"]
                        answer2_E = dict[str(id)][list_now[j]][str(k + 1)]["E"]
                        answer2_TC = dict[str(id)][list_now[j]][str(k + 1)]["TC"]
                        answer2_TR = dict[str(id)][list_now[j]][str(k + 1)]["TR"]
                        answer2_C = dict[str(id)][list_now[j]][str(k + 1)]["C"]
                        answer2_total = map_IP(answer2_IP) + answer2_E + answer2_TC + (answer2_TR + answer2_C) * 3

                        answer1 = answer_template
                        answer1 = answer1.replace("<INSTRUCTION>", dict[str(id)][list_now[i]][str(k + 1)]["instruction"])
                        answer1 = answer1.replace("<STEP_IDX>", str(step_idx))
                        answer1 = answer1.replace("<ACTION>", str(dict[str(id)][list_now[i]][str(k + 1)]["action"]))
                        answer1 = answer1.replace("<IP>", str(dict[str(id)][list_now[i]][str(k + 1)]["IP"]))
                        answer1 = answer1.replace("<E>", str(dict[str(id)][list_now[i]][str(k + 1)]["E"]))
                        answer1 = answer1.replace("<TC>", str(dict[str(id)][list_now[i]][str(k + 1)]["TC"]))
                        answer1 = answer1.replace("<TR>", str(dict[str(id)][list_now[i]][str(k + 1)]["TR"]))
                        answer1 = answer1.replace("<C>", str(dict[str(id)][list_now[i]][str(k + 1)]["C"]))
                        answer1 = answer1.replace("<TS>", str(answer1_total))

                        answer2 = answer_template
                        answer2 = answer2.replace("<INSTRUCTION>", dict[str(id)][list_now[i]][str(k + 1)]["instruction"])
                        answer2 = answer2.replace("<STEP_IDX>", str(step_idx))
                        answer2 = answer2.replace("<ACTION>", dict[str(id)][list_now[j]][str(k + 1)]["action"])
                        answer2 = answer2.replace("<IP>", str(dict[str(id)][list_now[j]][str(k + 1)]["IP"]))
                        answer2 = answer2.replace("<E>", str(dict[str(id)][list_now[j]][str(k + 1)]["E"]))
                        answer2 = answer2.replace("<TC>", str(dict[str(id)][list_now[j]][str(k + 1)]["TC"]))
                        answer2 = answer2.replace("<TR>", str(dict[str(id)][list_now[j]][str(k + 1)]["TR"]))
                        answer2 = answer2.replace("<C>", str(dict[str(id)][list_now[j]][str(k + 1)]["C"]))
                        answer2 = answer2.replace("<TS>", str(answer2_total))

                        if answer1_total > answer2_total:
                            chosen = answer1
                            chosen_image_url = dict[str(id)][list_now[i]][str(k + 1)]["observation_url"]
                            rejected = answer2
                            rejected_image_url = dict[str(id)][list_now[j]][str(k + 1)]["observation_url"]
                        elif answer1_total == answer2_total:
                            if len(dict[str(id)][list_now[i]]) < len(dict[str(id)][list_now[j]]):
                                chosen = answer1
                                chosen_image_url = dict[str(id)][list_now[i]][str(k + 1)]["observation_url"]
                                rejected = answer2
                                rejected_image_url = dict[str(id)][list_now[j]][str(k + 1)]["observation_url"]
                            elif len(dict[str(id)][list_now[i]]) > len(dict[str(id)][list_now[j]]):
                                chosen = answer2
                                chosen_image_url = dict[str(id)][list_now[j]][str(k + 1)]["observation_url"]
                                rejected = answer1
                                rejected_image_url = dict[str(id)][list_now[i]][str(k + 1)]["observation_url"]
                            else:
                                break
                        else:
                            chosen = answer2
                            chosen_image_url = dict[str(id)][list_now[j]][str(k + 1)]["observation_url"]
                            rejected = answer1
                            rejected_image_url = dict[str(id)][list_now[i]][str(k + 1)]["observation_url"]

                        # writer.writerow(
                        #     {'compare': str(list_now[i] + '_' + list_now[j]), 'step_idx': step_idx,
                        #      'prompt': prompt, 'initial_reason_steps': initial_reason_steps,
                        #      'image_url': chosen_image_url,
                        #      'chosen': chosen, 'rejected': rejected})

                        writer.writerow(
                            {'compare': str(list_now[i] + '_' + list_now[j]), 'step_idx': step_idx,
                             'prompt': prompt, 'initial_reason_steps': initial_reason_steps,
                             'image_url': chosen_image_url, 'images': Image.open(BytesIO(requests.get(chosen_image_url).content)),
                             'chosen': chosen, 'rejected': rejected})

                        step_idx += 1
                        initial_reason_steps += dict[str(id)][list_now[i]][str(k + 1)]["action"] + '\nStep ' + str(step_idx) + ":"

                        if not dict[str(id)][list_now[i]][str(k + 1)]["action"] == dict[str(id)][list_now[j]][str(k + 1)]["action"]:
                            break
                    except:
                        break